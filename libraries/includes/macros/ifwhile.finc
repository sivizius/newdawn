ifwhile@@gt                             equ                                     >
ifwhile@@ge                             equ                                     >=
ifwhile@@eq                             equ                                     =
ifwhile@@ne                             equ                                     <>
ifwhile@@le                             equ                                     <=
ifwhile@@ls                             equ                                     <


ifwhile@@lenQueque                      =                                       ( 1024 )
ifwhile@@lenStack                       =                                       ( 1024 )
ifwhile@@lenStrings                     =                                       ( 1024 * 1024 )
virtual                                 at null
  ifwhile@@theStrings::
    rb                                  ifwhile@@lenStrings
end virtual
ifwhile@@newStrings                     =                                       null
struc ifwhile@@addStrings               string
{
  local buffer, char
  virtual                               at null
    buffer:
      db string
    size                                =                                       ( $ )
    repeat ( size )
      load                              char byte                               from ( buffer + % - 1 )
      if (( ifwhile@@newStrings + % - 1 ) < ifwhile@@lenStrings )
        store                           byte char                               at ifwhile@@theStrings:( ifwhile@@newStrings + % - 1 )
      else
        display '[asm:ifwhile] ifwhile@@newStrings out of bonds! adjust ifwhile@@lenStrings.', 10
        err
      end if
    end repeat
  end virtual
  .                                     =                                       ifwhile@@newStrings
  .size                                 =                                       size
  ifwhile@@newStrings                   =                                       ( ifwhile@@newStrings + size )
}
virtual                                 at null
  ifwhile@@theQueque::
    rw                                  ifwhile@@lenQueque                      ;type
    rw                                  ifwhile@@lenQueque                      ;op
    rd                                  ifwhile@@lenQueque                      ;size
    rq                                  ifwhile@@lenQueque                      ;value
  ifwhile@@lenQueque                    =                                       ( $ )
end virtual
ifwhile@@newQueque                      =                                       null
ifwhile@@ptrQueque                      =                                       null
macro ifwhile@@addQueque                type,               op,                 size,               value
{
  if ( ifwhile@@newQueque >= ifwhile@@lenQueque )
    display '[asm:ifwhile] ifwhile@@newQueque >= ifwhile@@lenQueque! adjust ifwhile@@lenQueque.', 10
    err
  end if
  store                                 word  type                              at ifwhile@@theQueque:( ifwhile@@newQueque + 0 )
  store                                 word  op                                at ifwhile@@theQueque:( ifwhile@@newQueque + 2 )
  store                                 dword size                              at ifwhile@@theQueque:( ifwhile@@newQueque + 4 )
  store                                 qword value                             at ifwhile@@theQueque:( ifwhile@@newQueque + 8 )
  ifwhile@@newQueque                    =                                       ( ifwhile@@newQueque + 16 )
}
struc ifwhile@@enque                    type,               op,                 size,               value
{
  ifwhile@@addQueque                    type,               op,                 size,               value
  .                                     =                                       ifwhile@@newQueque
}
struc ifwhile@@deque
{
  local temp
  if ( ifwhile@@ptrQueque >= ifwhile@@newQueque )
    display '[asm:ifwhile] queque is empty!', 10
    err
  end if
  .                                     =                                       ifwhile@@ptrQueque
  load                                  temp word                               from ifwhile@@theQueque:( ifwhile@@ptrQueque + 0 )
  .type                                 =                                       temp
  load                                  temp word                               from ifwhile@@theQueque:( ifwhile@@ptrQueque + 2 )
  .op                                   =                                       temp
  load                                  temp dword                              from ifwhile@@theQueque:( ifwhile@@ptrQueque + 4 )
  .size                                 =                                       temp
  load                                  temp qword                              from ifwhile@@theQueque:( ifwhile@@ptrQueque + 8 )
  .value                                =                                       temp
  ifwhile@@ptrQueque                    =                                       ( ifwhile@@ptrQueque + 16 )
}
virtual                                 at null
  ifwhile@@theStack::
    rw                                  ifwhile@@lenStack                       ;type
    rw                                  ifwhile@@lenStack                       ;op
    rd                                  ifwhile@@lenStack                       ;size
    rq                                  ifwhile@@lenStack                       ;value
  ifwhile@@lenStack                     =                                       ( $ )
end virtual
ifwhile@@newStack                       =                                       null
ifwhile@@ptrStack                       =                                       null
macro ifwhile@@addStack                 type, op, size, value
{
  if ( ifwhile@@newStack >= ifwhile@@lenStack )
    display '[asm:ifwhile] ifwhile@@newStack >= ifwhile@@lenStack! adjust ifwhile@@lenStack.', 10
    err
  end if
  store                                 word  type                              at ifwhile@@theStack:( ifwhile@@newStack + 0 )
  store                                 word  op                                at ifwhile@@theStack:( ifwhile@@newStack + 2 )
  store                                 dword size                              at ifwhile@@theStack:( ifwhile@@newStack + 4 )
  store                                 qword value                             at ifwhile@@theStack:( ifwhile@@newStack + 8 )
  ifwhile@@newStack                     =                                       ( ifwhile@@newStack + 16 )
}
struc ifwhile@@push                     type, op, size, value
{
  ifwhile@@addStack                     type, op, size, value
  .                                     =                                       ifwhile@@newStack
}
struc ifwhile@@peek                     offs
{
  local temp, theOffset
  if ( offs eq )
    theOffset                           =                                       null
  else
    theOffset                           =                                       ( offs * 16 )
  end if
  if ( ifwhile@@newStack = 0 )
    display '[asm:ifwhile] stack is empty!', 10
    err
  end if
  .                                     =                                       ( ifwhile@@newStack - 16 )
  load                                  temp word                               from ifwhile@@theStack:( . + 0 )
  .type                                 =                                       temp
  load                                  temp word                               from ifwhile@@theStack:( . + 2 )
  .op                                   =                                       temp
  load                                  temp dword                              from ifwhile@@theStack:( . + 4 )
  .size                                 =                                       temp
  load                                  temp qword                              from ifwhile@@theStack:( . + 8 )
  .value                                =                                       temp
}
struc ifwhile@@pop
{
  . ifwhile@@peek
  ifwhile@@newStack                     =                                       ( ifwhile@@newStack - 16 )
}
struc ifwhile@@unstack
{
  local temp, op
  if ( ifwhile@@ptrStack >= ifwhile@@newStack )
    display '[asm:ifwhile] stack is empty!', 10
    err
  end if
  .                                     =                                       ifwhile@@ptrStack
  load                                  temp word                               from ifwhile@@theStack:( ifwhile@@ptrStack + 0 )
  .type                                 =                                       temp
  load                                  temp word                               from ifwhile@@theStack:( ifwhile@@ptrStack + 2 )
  .op                                   =                                       temp
  load                                  temp dword                              from ifwhile@@theStack:( ifwhile@@ptrStack + 4 )
  .size                                 =                                       temp
  load                                  temp qword                              from ifwhile@@theStack:( ifwhile@@ptrStack + 8 )
  .value                                =                                       temp
  ifwhile@@ptrStack                     =                                       ( ifwhile@@ptrStack + 16 )
}
macro ifwhile@@ParseExpression arg&
{
  local item, type, size, value, void, operant, mode, temp
  ifwhile@@newStack                     =                                       null
  ifwhile@@newQueque                    =                                       null
  operant                               =                                       true
  mode                                  =                                       null
  irps item, arg
  \{
    if ( \`item in < '!', '#', '%', '&', '*', '+', '-', '/', '<', '=', '>', '?', '|', '~'> )
      value                             =                                       ( \`item and 0xffffffff )
      display     'operator: ', \`item, 10
      if      (( \`item in < 'not', '-', '+', '~'> )                            & operant = true )
        size                            =                                       0
      else if (( \`item in < '!', '|', '&'> )                                   & operant = false )
        size                            =                                       1
      else if (( \`item in < '!', '|', '&'> )                                   & operant = true )
        temp ifwhile@@pop
        if ( temp#.value = \`item )
          value                         =                                       ( temp#.value or ( temp#.value shl 8 )
          size                          =                                       7
        else
          display '[asm:ifwhile] unexpected or unused or not-yet-implemented operator: »', temp#.value, \`item, '«!', 10
          err
        end if
        size                            =                                       2
      else if (( \`item in < '+', '-'> )                                        & operant = false )
        size                            =                                       2
      else if (( \`item in < '*', '/'> )                                        & operant = false )
        size                            =                                       3
      else if (( \`item eq '%' )                                                & operant = false )
        size                            =                                       4
      else if (( \`item in < '<', '>' > )                                       & operant = false )
        size                            =                                       6
      else if (( \`item eq '<' )                                                & operant = true )
        temp ifwhile@@pop
        if ( temp#.value = '<' )
          value                         =                                       '<<'
          size                          =                                       5
        else
          display '[asm:ifwhile] unexpected or unused or not-yet-implemented operator: »', temp#.value, '<«!', 10
          err
        end if
      else if (( \`item eq '>' )                                                & operant = true )
        temp ifwhile@@pop
        if ( temp#.value = '>' )
          value                         =                                       '>>'
          size                          =                                       5
        else
          display '[asm:ifwhile] unexpected or unused or not-yet-implemented operator: »', temp#.value, '>«!', 10
          err
        end if
      else if (( \`item eq '=' )                                                & operant = true )
        temp ifwhile@@pop
        if      ( temp#.value = '=' | temp#.value = '!' | temp#.value = '<' | temp#.value = '>' )
          value                         =                                       ( temp#.value or ( '=' shl 8 )
          size                          =                                       6
        else
          display '[asm:ifwhile] unexpected or unused or not-yet-implemented operator: »', temp#.value, '=«!', 10
          err
        end if
      else if (( \`item eq '=' )                                                & operant = false )
        size                            =                                       8
      else if (( \`item in < 'and', 'or', 'xor'> )                              & operant = false )
        size                            =                                       7
      else
        display '[asm:ifwhile] unexpected or unused or not-yet-implemented operator: »', \`item, '«!', 10
        err
      end if
      if ( ifwhile@@newStack > 0 )
        temp ifwhile@@pop
        while (( temp#.type         <>  op@@tFunction ) & \
               ( temp#.value        <>  '('           ) & \
               ( temp#.size         >=  size          ) & \
               ( ifwhile@@newStack  >   0             ))
          void ifwhile@@enque           temp#.type,         temp#.op,           temp#.size,         temp#.value
          temp ifwhile@@pop
        end while
        void ifwhile@@push              temp#.type,         temp#.op,           temp#.size,         temp#.value
      end if
      void ifwhile@@push                op@@tOperator,      mode,               size,               value
      operant                           =                                       true
    else if ( \`item eq '(' )
      display 'operator: (', 10
      if      ( operant = true )
        void ifwhile@@push              op@@tOperator,      mode,               null,               '('
        mode                            =                                       null
      else if ( mode = op@@tFunction )
        mode                            =                                       ( op@@tArgument )
        void ifwhile@@enque             op@@tArgument,      '(',                null,               null
        operant                         =                                       true
      else
        display '[asm:ifwhile] unxpected »(«!', 10
        err
      end if
    else if ( \`item eq ',' )
      display 'operator: ,', 10
      if ( operant = true )
        display '[asm:ifwhile] unfinished expression!', 10
        err
      else if ( mode = op@@tArgument )
        void ifwhile@@enque             op@@tArgument,      ',',                null,               null
        operant                         =                                       true
      else
        display '[asm:ifwhile] unxpected »,«!', 10
        err
      end if
    else if ( \`item eq ')' )
      display 'operator: )', 10
      if ( operant = true )
        display '[asm:ifwhile] unxpected »)«!', 10
        err
      else
        temp ifwhile@@pop
        while (( temp#.value  <> '(' ) & \
               ( temp#.type   <> op@@tFunction ))
          void ifwhile@@enque           temp#.type,         temp#.op,           temp#.size,         temp#.value
          temp ifwhile@@pop
        end while
        if ( temp#.type = op@@tFunction )
          void ifwhile@@enque           op@@tFunction,      temp#.op,           temp#.size,         temp#.value
        end if
        mode                            =                                       temp#.op
        operant                         =                                       false
      end if
    else
      operant                           =                                       false
      if      ( item eqtype rax )
        display   'register: ', \`item, 10
        void ifwhile@@enque             op@@tRegister,      item\#@@value,      item\#@@size,       item\#@@name
      else if ( item eqtype '' )
        display   'string: ', \`item, 10
        void ifwhile@@addStrings        \`item
        void ifwhile@@enque             op@@tString,        null,               void#.size,         void
      else if ( item eqtype 0 )
        if ( defined item )
          display 'constant: ', \`item, 10
          void ifwhile@@enque           op@@tConstant,      null,               null,               item
        else
          if ( defined item\#@@type )
            type                        =                                       item\#@@type
            op@@tName type, display
            display ': ', \`item, 10
            if ( type = op@@tFunction )
              void ifwhile@@push        op@@tFunction,      mode,               item\#@@size,       item\#@@value
              mode                      =                                       op@@tFunction
            else
              void ifwhile@@enque       type,               null,               item\#@@size,       item\#@@value
            end if
          else
            display 'unknown: ', \`item, 10
            err
          end if
        end if
      else
        display 'unknown: ', \`item, 10
        err
      end if
    end if
  \}
}
macro ifwhile@@DisplayExpression
{
  local temp, char
  ifwhile@@ptrQueque                    =                                       null
  while ( ifwhile@@ptrQueque < ifwhile@@newQueque )
    temp ifwhile@@deque
    if      ( temp#.type = op@@tOperator )
      display '['
      display (( temp#.value shr  0 ) and 0xff )
      display (( temp#.value shr  8 ) and 0xff )
      display (( temp#.value shr 16 ) and 0xff )
      display (( temp#.value shr 24 ) and 0xff )
      display (( temp#.value shr 32 ) and 0xff )
      display (( temp#.value shr 40 ) and 0xff )
      display (( temp#.value shr 48 ) and 0xff )
      display (( temp#.value shr 56 ) and 0xff )
      display ']'
    else if ( temp#.type = op@@tConstant )
      display '<0x'
      displayHex ( temp#.value )
      display '>'
    else if ( temp#.type = op@@tString )
      display '»'
      repeat ( temp#.size )
        load                            char byte                               from ifwhile@@theStrings:( temp#.value + % - 1 )
        display char
      end repeat
      display '«'
    else if ( temp#.type = op@@tRegister )
      display '<'
      display (( temp#.value shr  0 ) and 0xff )
      display (( temp#.value shr  8 ) and 0xff )
      display (( temp#.value shr 16 ) and 0xff )
      display (( temp#.value shr 24 ) and 0xff )
      display (( temp#.value shr 32 ) and 0xff )
      display (( temp#.value shr 40 ) and 0xff )
      display (( temp#.value shr 48 ) and 0xff )
      display (( temp#.value shr 56 ) and 0xff )
      display '>'
    else if ( temp#.type = op@@tArgument )
      display temp#.op
    else if ( temp#.type = op@@tFunction )
      display ')->@0x'
      displayHex ( temp#.value )
    else
      display '<?>'
    end if
  end while
  display 10
  ifwhile@@ptrQueque                    =                                       null
  while ( ifwhile@@ptrQueque < ifwhile@@newQueque )
    temp ifwhile@@deque
    op@@tName temp#.type, display
    display ', 0x'
    displayHex2 ( temp#.op )
    display ', 0x'
    displayHex4 ( temp#.size )
    display ', 0x'
    displayHex temp#.value
    display ', '
    display '<'
    display (( temp#.value shr  0 ) and 0xff )
    display (( temp#.value shr  8 ) and 0xff )
    display (( temp#.value shr 16 ) and 0xff )
    display (( temp#.value shr 24 ) and 0xff )
    display (( temp#.value shr 32 ) and 0xff )
    display (( temp#.value shr 40 ) and 0xff )
    display (( temp#.value shr 48 ) and 0xff )
    display (( temp#.value shr 56 ) and 0xff )
    display '>', 10
  end while
  display 10
}
macro ifwhile@@notImplemented           op1.type,           op1.op,             op1.size,           op1.value, \
                                        op2.type,           op2.op,             op2.size,           op2.value
{
  display '[asm:ifwhile] not yet implemented :-/ !', 10
  display '  op1: '
  op@@tName op1.type, display
  display ', 0x'
  displayHex2 ( op1.op )
  display ', 0x'
  displayHex4 ( op1.size )
  display ', 0x'
  displayHex op1.value
  display ', '
  display '<'
  display (( op1.value shr  0 ) and 0xff )
  display (( op1.value shr  8 ) and 0xff )
  display (( op1.value shr 16 ) and 0xff )
  display (( op1.value shr 24 ) and 0xff )
  display (( op1.value shr 32 ) and 0xff )
  display (( op1.value shr 40 ) and 0xff )
  display (( op1.value shr 48 ) and 0xff )
  display (( op1.value shr 56 ) and 0xff )
  display '>', 10
  display '  op2: '
  op@@tName op2.type, display
  display ', 0x'
  displayHex2 ( op2.op )
  display ', 0x'
  displayHex4 ( op2.size )
  display ', 0x'
  displayHex op2.value
  display ', '
  display '<'
  display (( op2.value shr  0 ) and 0xff )
  display (( op2.value shr  8 ) and 0xff )
  display (( op2.value shr 16 ) and 0xff )
  display (( op2.value shr 24 ) and 0xff )
  display (( op2.value shr 32 ) and 0xff )
  display (( op2.value shr 40 ) and 0xff )
  display (( op2.value shr 48 ) and 0xff )
  display (( op2.value shr 56 ) and 0xff )
  display '>', 10
  err
}
macro ifwhile@@addExpression
{
  local op1, op2, void, temp
  op2 ifwhile@@pop
  op1 ifwhile@@pop
  if      (( op1#.type = op@@tConstant ) & ( op2#.type = op@@tConstant ))
    void ifwhile@@push                  op@@tConstant,      null,               null,               ( op1#.value + op2#.value )
  else if (( op1#.type = op@@tConstant ) & ( op2#.type = op@@tRegister ))
    ifwhile@@RegisterFieldRead          =                                       ( ifwhile@@RegisterFieldRead or ( 1 shl ( op2#.op and ( not op@@regH ))))
    void ifwhile@@push                  op@@tOperator,      op2#.op,            op2#.size,          'mov2reg'
    void ifwhile@@push                  op1#.type,          op1#.op,            op1#.size,          op1#.value
    void ifwhile@@push                  op@@tOperator,      0x1337,             1,                  'add2reg'
  else if (( op1#.type = op@@tRegister ) & ( op2#.type = op@@tConstant ))
    ifwhile@@RegisterFieldRead          =                                       ( ifwhile@@RegisterFieldRead or ( 1 shl ( op1#.op and ( not op@@regH ))))
    void ifwhile@@push                  op@@tOperator,      op1#.op,            op1#.size,          'mov2reg'
    void ifwhile@@push                  op2#.type,          op2#.op,            op2#.size,          op2#.value
    void ifwhile@@push                  op@@tOperator,      0x1337,             2,                  'add2reg'
  else if (( op1#.type = op@@tOperator ) & ( op2#.type = op@@tConstant ))
    if ( op1#.op = 0x1337 )
      temp ifwhile@@peek
      if (( op1#.value = 'sub2reg'  | \
           op1#.value = 'add2reg' )   & \
           temp#.type = op@@tConstant )
        temp ifwhile@@pop
        void ifwhile@@push              op@@tConstant,      op2#.op,            op2#.size,          ( op2#.value + temp#.value )
        void ifwhile@@push              op@@tOperator,      0x1337,             3,                  'add2reg'
      else
        void ifwhile@@push              op1#.type,          op1#.op,            op1#.size,          op1#.value
        void ifwhile@@push              op2#.type,          op2#.op,            op2#.size,          op2#.value
        void ifwhile@@push              op@@tOperator,      0x1337,             4,                  'add2reg'
      end if
    else
      display '[asm:ifwhile] try to add an operator and a constant value!', 10
      err
    end if
  else if (( op1#.type = op@@tOperator ) & ( op2#.type = op@@tRegister ))
    void ifwhile@@push                  op1#.type,          op1#.op,            op1#.size,          op1#.value
    ifwhile@@RegisterFieldRead          =                                       ( ifwhile@@RegisterFieldRead or ( 1 shl ( op2#.op and ( not op@@regH ))))
    void ifwhile@@push                  op@@tStack,         op2#.op,            op2#.size,          null
    void ifwhile@@push                  op@@tOperator,      0x1337,             5,                  'add2reg'
  else
    ifwhile@@notImplemented             op1#.type,          op1#.op,            op1#.size,          op1#.value, \
                                        op2#.type,          op2#.op,            op2#.size,          op2#.value
  end if
}
macro ifwhile@@subExpression
{
  local op1, op2, type, op, size, value
  op2 ifwhile@@pop
  op1 ifwhile@@pop
  if (( op1#.type = op@@tConstant ) & ( op2#.type = op@@tConstant ))
    void ifwhile@@push                  op@@tConstant,      null,               null,               ( op1#.value - op2#.value )
  else
    ifwhile@@notImplemented             op1#.type,          op1#.op,            op1#.size,          op1#.value, \
                                        op2#.type,          op2#.op,            op2#.size,          op2#.value
  end if
}
macro ifwhile@@mulExpression
{
  local op1, op2, type, op, size, value
  op2 ifwhile@@pop
  op1 ifwhile@@pop
  if (( op1#.type = op@@tConstant ) & ( op2#.type = op@@tConstant ))
    void ifwhile@@push                  op@@tConstant,      null,               null,               ( op1#.value * op2#.value )
  else
    ifwhile@@notImplemented             op1#.type,          op1#.op,            op1#.size,          op1#.value, \
                                        op2#.type,          op2#.op,            op2#.size,          op2#.value
  end if
}
macro ifwhile@@divExpression
{
  local op1, op2, type, op, size, value
  op2 ifwhile@@pop
  op1 ifwhile@@pop
  if (( op1#.type = op@@tConstant ) & ( op2#.type = op@@tConstant ))
    void ifwhile@@push                  op@@tConstant,      null,               null,               ( op1#.value / op2#.value )
  else
    ifwhile@@notImplemented             op1#.type,          op1#.op,            op1#.size,          op1#.value, \
                                        op2#.type,          op2#.op,            op2#.size,          op2#.value
  end if
}
ifwhile@@RegisterFieldRead              =                                       null
ifwhile@@RegisterFieldWrite             =                                       null
macro ifwhile@@OptimizeExpression
{
  local temp, void
  ifwhile@@ptrQueque                    =                                       null
  ifwhile@@newStack                     =                                       null
  ifwhile@@RegisterFieldRead            =                                       null                                    ;do i need this register in calculation?
  while ( ifwhile@@ptrQueque < ifwhile@@newQueque )
    temp ifwhile@@deque
    if ( temp#.type = op@@tOperator )
      if      ( temp#.value = '+' )
        ifwhile@@addExpression
      else if ( temp#.value = '-' )
        ifwhile@@subExpression
      else if ( temp#.value = '*' )
        ifwhile@@mulExpression
      else if ( temp#.value = '/' )
        ifwhile@@divExpression
      else
        display '[asm:ifwhile] unknown or not yet implemented operator!', 10
        err
      end if
    else
      void ifwhile@@push                temp#.type,         temp#.op,           temp#.size,         temp#.value
    end if
  end while
  ifwhile@@newQueque                    =                                       null
  ifwhile@@ptrQueque                    =                                       null
  ifwhile@@ptrStack                     =                                       null
  while ( ifwhile@@ptrStack < ifwhile@@newStack )
    temp ifwhile@@unstack
    void ifwhile@@enque                 temp#.type,         temp#.op,           temp#.size,         temp#.value
  end while
}
macro ifwhile@@CompileExpression
{
  local temp
  local tempRegister, usedRegister, pushRegister
  local baseStack, baseRAX, baseRBX, baseRCX, baseRDX, baseCount
  tempRegister                          =                                       ( 0 - 1 )
  ifwhile@@RegisterFieldWrite           =                                       null                                    ;did i changed this register in calculation?
  ifwhile@@ptrQueque                    =                                       null
  ifwhile@@newStack                     =                                       null
  baseRAX                               =                                       ( 0 - 1 )
  baseRBX                               =                                       ( 0 - 1 )
  baseRCX                               =                                       ( 0 - 1 )
  baseRDX                               =                                       ( 0 - 1 )
  baseCount                             =                                       null
  optimizeStack                         =                                       true
  ;optimizeStack                         =                                       false
  usedRegister                          =                                       null
  repeat 4
    if (( ifwhile@@RegisterFieldRead and ( 1 shl ( % - 1 ))) & \
        (( pushRegister & ( 1 shl ( % - 1 ))) | ( ~ optimizeStack )))
      display 'push '
      if      (( % - 1 ) = op@@regA )
        display 'rax', 10
        baseRAX                         =                                       baseCount
        baseCount                       =                                       ( baseCount + 1 )
      else if (( % - 1 ) = op@@regB )
        display 'rbx', 10
        baseRBX                         =                                       baseCount
        baseCount                       =                                       ( baseCount + 1 )
      else if (( % - 1 ) = op@@regC )
        display 'rcx', 10
        baseRCX                         =                                       baseCount
        baseCount                       =                                       ( baseCount + 1 )
      else if (( % - 1 ) = op@@regD )
        display 'rdx', 10
        baseRDX                         =                                       baseCount
        baseCount                       =                                       ( baseCount + 1 )
      end if
    end if
  end repeat
  while ( ifwhile@@ptrQueque < ifwhile@@newQueque )
    temp ifwhile@@deque
    if ( temp#.type = op@@tOperator )
      if      ( temp#.value = 'mov2reg' )
        if (( ifwhile@@RegisterFieldWrite and ( 1 shl temp#.op )) | ( ~ optimizeStack ))
          tempRegister                  =                                       ( 0 - 1 )
          repeat 4
            if (~(( usedRegister                and ( 1 shl ( % - 1 )))   & \
                    ifwhile@@RegisterFieldRead  and ( 1 shl ( % - 1 )))))
              tempRegister              =                                       ( % - 1 )
              break
            end if
          end repeat
          if ( tempRegister < 0 )
            repeat 4
              if (~( usedRegister                and ( 1 shl ( % - 1 ))))
                tempRegister            =                                       ( % - 1 )
                break
              end if
            end repeat
          end if
          if ( tempRegister < 0 )
            display 'push rax', 10
            baseCount                   =                                       ( baseCount + 1 )
            tempRegister                =                                       op@@regA
          else
            ifwhile@@RegisterFieldWrite =                                       ( ifwhile@@RegisterFieldWrite or ( 1 shl tempRegister ))
          end if
          display 'mov '
          displayRegister tempRegister
          if      ( temp#.op = op@@regA )
            temp                        =                                       baseRAX
          else if ( temp#.op = op@@regB )
            temp                        =                                       baseRBX
          else if ( temp#.op = op@@regC )
            temp                        =                                       baseRCX
          else if ( temp#.op = op@@regD )
            temp                        =                                       baseRDX
          end if
          display     ', qword [ rsp + 0x'
          displayHex  ( __qword__ * ( baseCount - temp - 1 ))
          display     ' ]', 10
        else
          tempRegister                  =                                       temp#.op
        end if
      else if ( temp#.value = 'add2reg' )
        temp ifwhile@@pop
        if ( temp#.type = op@@tConstant )
          if ( temp#.value | ( ~ optimizeStack ))
            display 'add '
            displayRegister tempRegister
            displayValue ', 0x', temp#.value
          end if
        else if ( temp#.type = op@@tStack )
          display 'add '
          displayRegister tempRegister
          if (( ifwhile@@RegisterFieldWrite and ( 1 shl temp#.op )) | ( ~ optimizeStack ))
            if      ( temp#.op = op@@regA )
              temp                        =                                       baseRAX
            else if ( temp#.op = op@@regB )
              temp                        =                                       baseRBX
            else if ( temp#.op = op@@regC )
              temp                        =                                       baseRCX
            else if ( temp#.op = op@@regD )
              temp                        =                                       baseRDX
            end if
            display     ', qword [ rsp + 0x'
            displayHex  ( __qword__ * ( baseCount - temp - 1 ))
            display     ' ]', 10
          else
            display ', '
            displayRegister temp#.op
            display 10
          end if
        else
          display '[asm:ifwhile] compileAdd: not implemented yet :-/ !', 10
          err
        end if
      else if ( temp#.value = '' )
        display '[asm:ifwhile] epic fail!', 10
        err
      else
        display '[asm:ifwhile] unknown operator: »'
        display (( temp#.value shr  0 ) and 0xff )
        display (( temp#.value shr  8 ) and 0xff )
        display (( temp#.value shr 16 ) and 0xff )
        display (( temp#.value shr 24 ) and 0xff )
        display (( temp#.value shr 32 ) and 0xff )
        display (( temp#.value shr 40 ) and 0xff )
        display (( temp#.value shr 48 ) and 0xff )
        display (( temp#.value shr 56 ) and 0xff )
        display '«!', 10
        err
      end if
    else
      void ifwhile@@push                temp#.type,         temp#.op,           temp#.size,         temp#.value
    end if
  end while
  pushRegister                          =                                       ifwhile@@RegisterFieldWrite
  if ( baseCount | ( ~ optimizeStack ))
    display     'add rsp, ( __qword__ * 0x'
    displayHex  ( baseCount )
    display     ' )', 10
  end if
}

jnne                                    equ                                     je
struc ifwhile@@cmpjmp                   jmp_if_not,         cc,       debug,    ccc,      arg1,     arg2
{
  display debug, 10
  local op1, op2
  op1                                   op@@type                                arg1
  op2                                   op@@type                                arg2
  if      ( op1#@@type = op@@tConstant )
    if      ( op2#@@type = op@@tConstant )
      if ~( op1#@@value ccc op2#@@value )
        jmp                         jmp_if_not
      end if
    end if
  else if ( op1#@@type = op@@tRegister )
    if      ( op2#@@type = op@@tConstant )
      cmp                               op1#@@register,                         op2#@@value
      jn#cc                             jmp_if_not
    end if
  else if ( op1#@@type = op@@tMemory )
    if      ( op2#@@type = op@@tConstant )
      cmp                               arg1,                                   op2#@@value
      jn#cc                             jmp_if_not
    end if
  end if
  .                                     equ                                     true
}
macro ifwhile@@cond                     jmp_if_not,                             arg
{
  local hazCarry, hazOverflow, hazParity, hazSign, hazZero
  local done, op1, op2, operant, ccc, arg1, arg2
  hazCarry                              equ
  hazOverflow                           equ
  hazParity                             equ
  hazSign                               equ
  hazZero                               equ
  display 'parse...', 10
  done                                  equ
  match =CARRY?, arg
  \{
    match any, hazCarry
    \\{
      display '[asm:ifwhile] carry-flag already checked!', 10
      err
    \\}
    hazCarry                            equ                                     =
    jnc                                 jmp_if_not
    done                                equ                                     true
  \}
  match =!CARRY?, arg
  \{
    match any, hazCarry
    \\{
      display '[asm:ifwhile] carry-flag already checked!', 10
      err
    \\}
    hazCarry                            equ                                     =
    jc                                  jmp_if_not
    done                                equ                                     true
  \}
  match =OVERFLOW?, arg
  \{
    match any, hazOverflow
    \\{
      display '[asm:ifwhile] overflow-flag already checked!', 10
      err
    \\}
    hazOverflow                         equ                                     =
    jno                                 jmp_if_not
    done                                equ                                     true
  \}
  match =!OVERFLOW?, arg
  \{
    match any, hazOverflow
    \\{
      display '[asm:ifwhile] overflow-flag already checked!', 10
      err
    \\}
    hazOverflow                         equ                                     =
    jo                                  jmp_if_not
    done                                equ                                     true
  \}
  match =PARITY?, arg
  \{
    match any, hazParity
    \\{
      display '[asm:ifwhile] parity-flag already checked!', 10
      err
    \\}
    hazParity                           equ                                     =
    jnp                                 jmp_if_not
    done                                equ                                     true
  \}
  match =!PARITY?, arg
  \{
    match any, hazParity
    \\{
      display '[asm:ifwhile] parity-flag already checked!', 10
      err
    \\}
    hazParity                           equ                                     =
    jp                                  jmp_if_not
    done                                equ                                     true
  \}
  match =SIGN=?, arg
  \{
    match any, hazSign
    \\{
      display '[asm:ifwhile] sign-flag already checked!', 10
      err
    \\}
    hazSign                             equ                                     =
    jns                                 jmp_if_not
    done                                equ                                     true
  \}
  match =!SIGN=?, arg
  \{
    match any, hazSign
    \\{
      display '[asm:ifwhile] sign-flag already checked!', 10
      err
    \\}
    hazSign                             equ                                     =
    js                                  jmp_if_not
    done                                equ                                     true
  \}
  match =ZERO=?, arg
  \{
    match any, hazZero
    \\{
      display '[asm:ifwhile] zero-flag already checked!', 10
      err
    \\}
    hazZero                             equ                                     =
    jnz                                 jmp_if_not
    done                                equ                                     true
  \}
  match =!ZERO=?, arg
  \{
    match any, hazZero
    \\{
      display '[asm:ifwhile] zero-flag already checked!', 10
      err
    \\}
    hazZero                             equ                                     =
    jz                                  jmp_if_not
    done                                equ                                     true
  \}
  done                                  equ                                     xxx
  match =xxx arg1 <>   arg2, done arg \{ done ifwhile@@cmpjmp                   jmp_if_not,         ne,       '<>',     ifwhile@@ne,        arg1,     arg2 \}
  match =xxx arg1 <==  arg2, done arg \{ done ifwhile@@cmpjmp                   jmp_if_not,         be,       '<=',     ifwhile@@le,        arg1,     arg2 \}
  match =xxx arg1 <<== arg2, done arg \{ done ifwhile@@cmpjmp                   jmp_if_not,         le,       '<<=',    ifwhile@@le,        arg1,     arg2 \}
  match =xxx arg1 <<   arg2, done arg \{ done ifwhile@@cmpjmp                   jmp_if_not,         l,        '<<',     ifwhile@@ls,        arg1,     arg2 \}
  match =xxx arg1 <    arg2, done arg \{ done ifwhile@@cmpjmp                   jmp_if_not,         b,        '<',      ifwhile@@ls,        arg1,     arg2 \}
  match =xxx arg1 ==== arg2, done arg \{ done ifwhile@@cmpjmp                   jmp_if_not,         e,        '==',     ifwhile@@eq,        arg1,     arg2 \}
  match =xxx arg1 =!== arg2, done arg \{ done ifwhile@@cmpjmp                   jmp_if_not,         ne,       '!=',     ifwhile@@ne,        arg1,     arg2 \}
  match =xxx arg1 >==  arg2, done arg \{ done ifwhile@@cmpjmp                   jmp_if_not,         ae,       '>=',     ifwhile@@ge,        arg1,     arg2 \}
  match =xxx arg1 >>== arg2, done arg \{ done ifwhile@@cmpjmp                   jmp_if_not,         ge,       '>>=',    ifwhile@@ge,        arg1,     arg2 \}
  match =xxx arg1 >>   arg2, done arg \{ done ifwhile@@cmpjmp                   jmp_if_not,         g,        '>>',     ifwhile@@gt,        arg1,     arg2 \}
  match =xxx arg1 >    arg2, done arg \{ done ifwhile@@cmpjmp                   jmp_if_not,         a,        '>',      ifwhile@@gt,        arg1,     arg2 \}
  match =xxx, done
  \{
    display '[asm:ifwhile] could not parse »', `arg, '«!', 10
    err
  \}
}
macro @if                               arg
{
  local ifwhile@@else, ifwhile@@fi
  ..ifwhile@@IFIF                       equ
  ..ifwhile@@ELSE                       equ                                     ifwhile@@else
  ..ifwhile@@FIFI                       equ                                     ifwhile@@fi
  ifwhile@@cond                         ..ifwhile@@ELSE,                        arg
}
macro @elif                             arg
{
  jmp                                   ..ifwhile@@FIFI
  ..ifwhile@@ELSE:
  restore                               ..ifwhile@@ELSE
  local ifwhile@@else
  ..ifwhile@@ELSE                       equ                                     ifwhile@@else
  ifwhile@@cond                         ..ifwhile@@ELSE,                        arg
}
macro @else
{
  jmp                                   ..ifwhile@@FIFI
  ..ifwhile@@ELSE:
  restore                               ..ifwhile@@IFIF
  ..ifwhile@@IFIF                       equ                                     ,
}
macro @fi
{
  if ( ..ifwhile@@IFIF eq )
    ..ifwhile@@ELSE:
  end if
  ..ifwhile@@FIFI:
  restore                               ..ifwhile@@ELSE
  restore                               ..ifwhile@@FIFI
  restore                               ..ifwhile@@IFIF
}
macro @while                            arg
{
  local ifwhile@@loop, ifwhile@@done
  ..ifwhile@@LOOP                       equ                                     ifwhile@@loop
  ..ifwhile@@DONE                       equ                                     ifwhile@@done
  ..ifwhile@@LOOP:
  ifwhile@@cond                         ..ifwhile@@DONE,                        arg
}
macro @repeat
{
  local ifwhile@@loop, ifwhile@@done
  ..ifwhile@@LOOP                       equ                                     ifwhile@@loop
  ..ifwhile@@DONE                       equ                                     ifwhile@@done
  ..ifwhile@@LOOP:
}
macro @for                              init,     step,     stop
{
  local ifwhile@@loop, ifwhile@@done
  ifwhile@@FORARG                       equ                                     init, step, stop
  ..ifwhile@@LOOP                       equ                                     ifwhile@@loop
  ..ifwhile@@DONE                       equ                                     ifwhile@@done
  ..ifwhile@@LOOP:
}
macro @done
{
  jmp                                   ..ifwhile@@LOOP
  ..ifwhile@@DONE:
  restore                               ..ifwhile@@DONE
  restore                               ..ifwhile@@LOOP
}
macro @until                            arg
{
  ifwhile@@cond                         ..ifwhile@@DONE,                        arg
  ..ifwhile@@DONE:
  restore                               ..ifwhile@@DONE
  restore                               ..ifwhile@@LOOP
}
macro @next
{
  ;< ... >
  ..ifwhile@@DONE:
  restore                               ..ifwhile@@DONE
  restore                               ..ifwhile@@LOOP
  restore                               ifwhile@@FORARG
}
macro @break
{
  jmp                                   ..ifwhile@@DONE
}
macro @continue
{
  jmp                                   ..ifwhile@@LOOP
}
